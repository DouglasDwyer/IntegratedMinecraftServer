using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace IMS_Library
{
    public static class MinecraftConfigurationWriter
    {
        public static void WriteServerPropertiesFile(string fileName, ServerConfiguration configuration)
        {
            string toWrite = "#IMS AUTOGENERATED\n";
            foreach (FieldInfo info in configuration.GetType().GetFields(BindingFlags.Public | BindingFlags.Instance))
            {
                ServerProperty property = info.GetCustomAttribute<ServerProperty>();
                if (property != null)
                {
                    toWrite += property.GetData(configuration, info) + "\n";
                }
            }
            File.WriteAllText(configuration.GetServerFolderLocation() + "/" + fileName, toWrite);
        }

        public static void WriteEULA(string fileName, ServerConfiguration configuration)
        {
            File.WriteAllText(configuration.GetServerFolderLocation() + "/" + fileName, "eula=true");
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public class ServerProperty : Attribute
    {
        public string PropertyName;

        public ServerProperty(string propertyName)
        {
            PropertyName = propertyName;
        }

        public virtual string GetData(ServerConfiguration configuration, FieldInfo field)
        {
            if(field.FieldType == typeof(string) || field.FieldType == typeof(int))
            {
                return PropertyName + "=" + field.GetValue(configuration);
            }
            else if(field.FieldType == typeof(bool))
            {
                if((bool)field.GetValue(configuration))
                {
                    return PropertyName + "=true";
                }
                else
                {
                    return PropertyName + "=false";
                }
            }
            else if(field.FieldType == typeof(WebPort))
            {
                return PropertyName + "=" + ((WebPort)field.GetValue(configuration)).Port;
            }
            else
            {
                throw new NotImplementedException("Cannot write type " + field.FieldType + " into the server.properties file.");
            }
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public class MOTDServerProperty : ServerProperty
    {
        public MOTDServerProperty(string propertyName) : base(propertyName)
        {
        }

        public override string GetData(ServerConfiguration configuration, FieldInfo field)
        {
            string[] data = Regex.Split((string)field.GetValue(configuration), @"(?=<)|(?<=>)");
            string finalString = PropertyName + "=" + ActiveModifiers.FormattingResetCharacter;
            ActiveModifiers textModifiers = new ActiveModifiers();
            //could be refactored but i mean it works
            foreach (string subelement in data)
            {
                switch (subelement) {
                    case "<b>":
                    case "<b style=\"\">":
                        textModifiers.Bold = true;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "</b>":
                        textModifiers.Bold = false;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "<i>":
                    case "<i style=\"\">":
                        textModifiers.Italic = true;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "</i>":
                        textModifiers.Italic = false;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "<u>":
                    case "<u style=\"\">":
                        textModifiers.Underline = true;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "</u>":
                        textModifiers.Underline = false;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "<strike>":
                    case "<strike style=\"\">":
                        textModifiers.Strikethrough = true;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "</strike>":
                        textModifiers.Strikethrough = false;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "<sup>":
                    case "<sup style=\"\">":
                        textModifiers.Obfuscated = true;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "</sup>":
                        textModifiers.Obfuscated = false;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "</font>":
                        textModifiers.Color = null;
                        finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        break;
                    case "<div>":
                        finalString += "\\n";
                        break;
                    case "</div>":
                        break;
                    default:
                        Match regexMatch;
                        if(CheckRegexMatch(subelement, "^<font color=\"([#0123456789abcdef]*)\">$", out regexMatch))
                        {
                            textModifiers.Color = regexMatch.Groups[1].Value;
                            finalString += ActiveModifiers.FormattingResetCharacter + textModifiers.GetFormattingCodes();
                        }
                        else
                        {
                            finalString += WebUtility.HtmlDecode(subelement.Replace("&nbsp;", " "));
                        }
                        break;
                }
            }
            return finalString;
        }

        private bool CheckRegexMatch(string input, string pattern, out Match match)
        {
            Regex regex = new Regex(pattern);
            match = regex.Match(input);
            return match.Success;
        }

        protected struct ActiveModifiers
        {
            public bool Bold, Italic, Underline, Strikethrough, Obfuscated;
            public string Color;

            public const string FormattingCharacter = "\\u00A7";
            public const string FormattingResetCharacter = FormattingCharacter + "r";

            public string GetFormattingCodes()
            {
                string finalString = "";
                if(!string.IsNullOrEmpty(Color))
                {
                    finalString += FormattingCharacter + Constants.MinecraftColorsHexAndFormattingCodes[Color];
                }
                if(Bold)
                {
                    finalString += FormattingCharacter + "l";
                }
                if(Italic)
                {
                    finalString += FormattingCharacter + "o";
                }
                if(Underline)
                {
                    finalString += FormattingCharacter + "n";
                }
                if (Strikethrough)
                {
                    finalString += FormattingCharacter + "m";
                }
                if (Obfuscated)
                {
                    finalString += FormattingCharacter + "k";
                }
                return finalString;
            }
        }
    }
}
